\chapter{Giới thiệu NoSQL và MongoDB}
\section{Mở đầu}
Hiện nay khi nói đến cơ sở dữ liệu, có sự phân chia rõ ràng giữa 2 trường phái kĩ thuật cơ sở dữ liệu là SQL và NoSQL - hay còn gọi cách khác là Cơ sở dữ liệu Quan hệ và Cơ sở dữ liệu Phi Quan hệ. Trong các chương trình giảng dạy ở bậc đại học thì thường chú trọng vào nghiên cứu và tìm hiểu các nguyên lý, cấu tạo của cơ sở dữ liệu SQL mà không khai thác các cơ sở dữ liệu NoSQL. Do đó ở bài báo cáo này, chúng ta sẽ tập trung tìm hiểu và khai thác kiến thức về các cơ sở dữ liệu NoSQL mà đối tượng nghiên cứu cụ thể tiêu biểu là MongoDB.

\section{NoSQL - Non SQL}
Đầu tiên, ta sẽ giới thiệu về NoSQL. Bên cạnh đó nêu ra cách phân loại các cơ sở dữ liệu NoSQL và nêu ra các điểm khác nhau nổi bật giữa cơ sở dữ liệu NoSQL và cơ sở dữ liệu quan hệ truyền thống.
\subsection{Giới thiệu}
Tuy NoSQL đã xuất hiện từ thập niên 60 nhưng thời gian gần đây nó mới bắt đầu tìm được vị trí của mình. Như tên gọi của nó, NoSQL cung cấp cơ chế triển khai cơ sở dữ liệu không theo cấu trúc nhất định. SQL đã tận dụng tốt việc khai báo schema chặt chẽ để quản lý, lưu trữ dữ liệu một cách tối ưu và cung cấp cho người dùng phương tiện để truy cập, sử dụng cơ sở dữ liệu hiệu quả nhất, nhờ đó mà nó đã từng là lựa chọn hàng đầu cho việc triển khai cơ sở dữ liệu.

Trong thời đại hiện nay, với sự bùng nổ của các dịch vụ internet kéo theo sự bùng nổ dữ liệu người dùng phi cấu trúc. Chính sự chặt chẽ của cơ sở dữ liệu SQL đã gây khó khăn trong việc quản lý, lưu trữ các dữ liệu phi cấu trúc này do SQL chỉ hoạt động tốt trên dữ liệu có cấu trúc. Điều này đã tạo cơ hội cho NoSQL phát huy điểm mạnh của mình.
\subsection{Phân loại}
Cơ sở dữ liệu NoSQL sử dụng khai báo schema động để quản lý cơ sở dữ liệu theo nhiều cách khác nhau, dựa vào đó ta có thể phân chúng thành nhiều loại:
\begin{itemize}
\item \textbf{Key-value store} mô hình SQL đơn giản nhất, lưu trữ dữ liệu dưới dạng khóa và trị. Tiêu biểu: ArangoDB, Aerospike, Oracle NoSQL Database, Dynamo, Riak, Voldemort.
\item \textbf{Column store} lưu các bảng dữ liệu theo dạng cột như đơn vị lưu trữ nhỏ nhất thay vì theo hàng như truyền thống. Tiêu biểu: Amazon DynamoDB, Bigtable, Cassandra, Druid, HBase, Hypertable.
\item \textbf{Document store} với ý tưởng chính là việc định nghĩa "document", là đơn vị dữ liệu nhỏ nhất chứa dữ liệu của bản thân nó và có mang key để phục vụ việc truy xuất. Ngoài việc truy xuất theo khóa thì các Document-Database này còn cung cấp các API giúp truy xuất document dựa trên nội dung nó chứa. Tiêu biểu: \textbf{\textit{MongoDB}}, ArangoDB, BaseX, Clusterpoint, Couchbase, CouchDB, DocumentDB, IBM Domino, MarkLogic, Qizx, RethinkDB.
\item \textbf{Graph} thường được dùng cho dữ liệu mà quan hệ giữa các thực thể có thể được biểu diễn tốt bằng đồ thị. Tiêu biểu: Neo4J, Polyglot.
\end{itemize}
\section{So sánh SQL và NoSQL}
\subsection{Query phức tạp}
Nhờ vào cấu trúc chặt chẽ của mình nên SQL có khả năng thực hiện các câu query phức tạp một cách tối ưu nhất so với NoSQL.
\subsection{ACID}
Tuân thủ ACID giúp CSDL SQL bảo vệ tính toàn vẹn, đảm bảo tính hợp lý của transaction. Tuy nhiên CSDL NoSQL bỏ qua ACID để có thể trở nên linh động và tăng tốc độ xử lý.
\subsection{Dữ liệu lưu trữ}
SQL chỉ có thể lưu trữ có cấu trúc. NoSQL có thể lưu trữ dữ liệu có cấu trúc hoặc phi cấu trúc.
\subsection{Khả năng mở rộng}
SQL khả mở rộng độ sâu của CSDL trong khi NoSQL khả mở rộng chiều ngang, giúp cho CSDL có thể được phân tán ở nhiều server qua đó tăng hiệu suất truy xuất dữ liệu, phù hợp cho các CSDL lớn và thay đổi liên tục.
\subsection{Cấu trúc}
Trong khi SQL ràng buộc việc khai báo schema rõ ràng trước khi có thể thêm dữ liệu thì với NoSQL ta có thể tạo document mà không cần khai báo schema trước. Mỗi document có cấu trúc, schema khác nhau.
\newpage
\section{MongoDB} \label{sec:MongoDB}
Sau khi đã tìm hiểu về NoSQL nói chung ở phần trước thì phần này ta sẽ đi vào chi tiết cụ thể về một điển hình tiêu biểu của NoSQL là MongoDB. Ở phần \ref{ssec:MongoDB.1} ta sẽ giới thiệu sơ bộ về MongoDB bên cạnh các khái niệm về các đơn vị và cấu trúc cơ bản của một CSDL xây dựng bằng MongoDB. Sau đó ta sẽ liệt kê sơ bộ các loại dữ liệu trong phần \ref{ssec:MongoDB.2} và các lệnh cơ bản nhất trong phần \ref{ssec:MongoDB.3}.
\subsection{Giới thiệu} \label{ssec:MongoDB.1}
MongoDB là hệ CSDL NoSQL Document store mở. Mỗi record trong MongoDB là một \textbf{\textit{document}}, gồm có các cặp trường và trị, và mỗi bảng sẽ là \textbf{\textit{collection}}, tập hợp nhiều document, và \textbf{\textit{Database}} là tập hợp của nhiều collection. Do cấu trúc linh động nên bảng không có schema cố định mà schema của mỗi document sẽ tự do document quản lý và quyết định. Document của MongoDB có cấu trúc gần giống với các đối tượng JSON. Các giá trị có thể là document khác hoặc mảng hoặc mảng các document.
\subsection{Datatype} \label{ssec:MongoDB.2}
Ngoài việc hỗ trợ các datatype thông dụng trong các ngôn ngữ lập trình, MongoDB còn định nghĩa một số datatype khác nhau:
\begin{itemize}
\item \textbf{Date}
\item \textbf{ObjectId} là kiểu dữ liệu được MongoDB dùng mặc định để đánh Id cho các document trong collection
\item \textbf{Số} MongoDB mặc định lưu trữ các dữ liệu số dưới dạng double 64-bit. Bên cạnh đó còn cung cấm nhiều wrapper để đặc tả các số một cách cụ thể như:
\begin{itemize}
\item \textbf{NumberLong} 64-bit integer
\item \textbf{NumberInt} 32-bit integer
\item \textbf{NumberDecimal} 128-bit decimal-based floating-point numbers
\end{itemize}
\end{itemize}
\subsection{Các thao tác cơ bản trong MongoDB sử dụng mongo shell - CRUD} \label{ssec:MongoDB.3}
\subsubsection{Create}
\begin{itemize}
\item 
\begin{lstlisting} 
use DATABASE_NAME
\end{lstlisting}
sẽ truy cập database có tên \textit{DATABASE\_NAME} hoặc tạo nếu chưa tồn tại và truy cập database vừa tạo.
\item 
\begin{lstlisting}
db.createCollection(collection_name, options)
\end{lstlisting}
dùng để tạo một collection tên \textit{collection\_name} và có thể khai báo thêm một số option như capped, size, max - Giới hạn kích thước hay số lượng document tối đa của collection - hay autoIndexId - tự động index trường \_id của document.
\item
\begin{lstlisting}
db.collection_name.insert(document)

db.collection_name.insertOne(document)
\end{lstlisting}
thêm \textit{document} vào collection \textit{collection\_name}
\item
\begin{lstlisting}
db.collection_name.insertMany(documents)
\end{lstlisting}
thêm tất cả các document trong danh sách \textit{documents} vào collection \textit{collection\_name}
\end{itemize}
\subsubsection{Read}
\begin{itemize}
\item
\begin{lstlisting}
show dbs
\end{lstlisting}
xuất cái database hiện có.
\item
\begin{lstlisting}
show collections
\end{lstlisting}
xuất danh sách các collection trong database hiện tại.
\item
\begin{lstlisting}
db.collection_name.find()
\end{lstlisting}
xuất tất cả document trong collection \textit{collection\_name}.
\item
\begin{lstlisting}
db.collection_name.find(query)
\end{lstlisting}
xuất tất cả document trong collection \textit{collection\_name} thỏa điều kiện \textit{query}.
\end{itemize}
\subsubsection{Update}
\begin{itemize}
\item
\begin{lstlisting}
db.colletion_name.updateOne(query, action)
\end{lstlisting}
thực hiện update được mô tả trong \textit{action} trên document thỏa điều kiện \textit{query} trong \textit{collection\_name}. Nếu có nhiều hơn 1 document thỏa \textit{query} thì sẽ thực hiện \textit{action} trên document đầu tiền thỏa.
\item
\begin{lstlisting}
db.colletion_name.updateMany(query, action)
\end{lstlisting}
thực hiện update được mô tả trong \textit{action} trên tất cả document thỏa điều kiện \textit{query} trong \textit{collection\_name}.
\item
\begin{lstlisting}
db.colletion_name.replaceOne(query, document)
\end{lstlisting}
thay thế document thỏa \textit{query} trong \textit{collection\_name} bằng \textit{document}. Nếu có nhiều hơn 1 document thỏa \textit{query} trong collection thì thực hiện thay thế trên document đầu tiên thỏa.
\end{itemize}
\subsubsection{Delete}
\begin{itemize}
\item
\begin{lstlisting}
db.dropDatabase()
\end{lstlisting}
dùng để xóa database đang truy cập.
\item
\begin{lstlisting}
db.collection_name.drop()
\end{lstlisting}
dùng để drop collection có tên \textit{collection\_name}
\item
\begin{lstlisting}
db.colletion_name.deleteOne(query)
\end{lstlisting}
xóa một document thỏa \textit{query} trong \textit{collection\_name}. Nếu có nhiều hơn 1 document thỏa \textit{query} trong collection thì xóa document đầu tiên thỏa.
\item
\begin{lstlisting}
db.colletion_name.deleteMany(filter)
\end{lstlisting}
xóa tất cả document thỏa \textit{filter} trong \textit{collection\_name}.
\end{itemize}
\subsection{Câu Query}
Câu query đóng vai trò quan trọng trong việc tìm kiếm, truy xuất, cập nhật Database. MongoDB cung cấp bộ quy tắc để viết các câu query tiện lợi, nhất quán.
\subsubsection{Cơ bản nhất}
\begin{lstlisting}
{<field>:<value>, ...}
\end{lstlisting}
Câu query cơ bản nhất trong MongoDB chính là so sánh bằng. Câu query cấu tạo từ các cặp khóa-trị với biểu diễn mối quan hệ trường và giá trị của trường, câu query sẽ truy xuất tất cả các document có trường được định trong \textit{<field>} có giá trị \textit{<value>}. Do câu query có cấu tạo là tập hợp nhiều cặp khóa-trị nên có bản chất \textit{AND}. Ví dụ như:
\begin{lstlisting}
db.NhanVien.find({luong:2000, mspb: "P01"})
\end{lstlisting}
câu query trên sẽ giúp phép find truy xuất tất cả các Nhân viên có \textit{lương} là 2000 và \textit{mspb} là 
"P01". Phép find cùng câu query trên tương tự như câu query trong SQL:
\begin{lstlisting}
select * from NhanVien where luong=2000 and mspb="P01"
\end{lstlisting}

Bên cạnh đó, ở \textit{\textbf{<value>}} ta có thể thay giá trị cụ thể bằng các kết hợp toán tử so sánh, OR, AND,... để phức tạp hóa câu query nhằm phục vụ mục đích của mình.
\subsubsection{Các toán tử so sánh để chọn}
Dùng các toán tử để chọn từ dữ liệu các document có giá trị trường \textit{<field>} thỏa:
\begin{itemize}
\item \lstinline!$eq! bằng. cú pháp: \lstinline!<field> : {$eq: <value>}! \\* ví dụ như \lstinline!db.NhanVien.find({luong: {$eq: 2000}})! truy xuất tất cả nhân viên có lương 2000. Tuy nhiên câu query trên cũng tương đương bản rút gọn ta đã tìm hiểu qua ở phần trước \lstinline!db.NhanVien.find({luong:2000})!.
\item \lstinline!$ne! không bằng. cú pháp: \lstinline!<field> : {$ne: <value>}! \\* ví dụ như \lstinline!db.NhanVien.find({luong: {$ne: 2000}})! truy xuất tất cả nhân viên có lương khác 2000.
\item \lstinline!$gt! lớn hơn. cú pháp: \lstinline!<field> : {$gt: <value>}! \\* ví dụ như \lstinline!db.NhanVien.find({luong: {$gt: 2000}})! truy xuất tất cả nhân viên có lương lớn hơn 2000.
\item \lstinline!$gte! lớn hơn hoặc bằng. cú pháp: \lstinline!<field> : {$gte: <value>}! \\* ví dụ như \lstinline!db.NhanVien.find({luong: {$gte: 2000}})! truy xuất tất cả nhân viên có lương lớn hơn hoặc bằng 2000.
\item \lstinline!$lt! nhỏ hơn. cú pháp: \lstinline!<field> : {$lt: <value>}! \\* ví dụ như \lstinline!db.NhanVien.find({luong: {$lt: 2000}})! truy xuất tất cả nhân viên có lương nhỏ hơn 2000.
\item \lstinline!$lte! nhỏ hơn hoặc bằng. \\* ví dụ như \lstinline!db.NhanVien.find({luong: {$lte: 2000}})! truy xuất tất cả nhân viên có lương nhỏ hơn hoặc bằng 2000.
\item \lstinline!$in! giá trị trong danh sách các giá trị được định. cú pháp: \lstinline!<field> : {$in: [<value0>, <value1>, ..., <valueN>]}! \\* ví dụ như \lstinline!db.NhanVien.find({mspb: {$in: ["P01","P04"]}})! truy xuất tất cả nhân viên thuộc phòng ban có mã số	trong danh sách \lstinline!["P01","P04"]! được định. Tác vụ trên tương đương câu query trong SQL \lstinline!select * from NhanVien where mspb in ("P01","P04")!.
\item \lstinline!$nin! giá trị không nằm trong danh sách các giá trị đã được định. cú pháp: \lstinline!<field> : {$nin: [<value0>, <value1>, ..., <valueN>]}! \\* ví dụ như \lstinline!db.NhanVien.find({mspb: {$nin: ["P01","P04"]}})! truy xuất tất cả nhân viên không thuộc phòng ban có mã số	trong danh sách \lstinline!["P01","P04"]! được định.
\end{itemize}
\subsubsection{Các toán tử logic}
Ngoài các toán tử so sánh toán học, MongoDB còn cung cấp các toán tử logic như:
\begin{itemize}
\item \lstinline!$and! cú pháp: \lstinline!{$and: [ {<expression0>}, {<expression1>}, ... ,{<expressionN>} ] }! với \textit{expression} là các câu điều query khác. \\* ví dụ như \lstinline!db.NhanVien.find({$and: [{luong: 2000}, {mspb:"P01"}]})! truy xuất tất cả nhân viên có lương 2000 và thuộc phòng ban có mspb "P01". Tác vụ truy xuất trên tương đương với câu query SQL \lstinline!select * from NhanVien where luong=2000 and mspb="P01"! . Ta có thể thấy nó tương đương với câu query cơ bản \lstinline!db.NhanVien.find({luong:2000},{mspb:"P01"})!.
\item \lstinline!$or! cú pháp: \lstinline!{$or: [ {<expression0>}, {<expression1>}, ... ,{<expressionN>} ] }! \\* ví dụ như \lstinline!db.NhanVien.find({$or: [ {luong:2000}, {mspb:"P02"}]})! truy xuất tất cả nhân viên có lương 2000 hoặc thuộc phòng ban có mã số "P02".
\item \lstinline!$not! truy xuất các document không thỏa điều kiện được định hoặc \textbf{không có trường được định}. cú pháp: \lstinline!{<field> : {$not: {<expression>}}}! với \textit{<expression>} là các cụm query bằng sử dụng toán tử toán học. \\* ví dụ như: \lstinline!db.NhanVien.find({ngay_nghi: {$not: {$gt: 3}}})! truy xuất tất cả nhân viên có ngày nghỉ \textit{bé hơn hoặc bằng} 3 hoặc \textbf{không có trường ngay\_nghi}.
\item \lstinline!$nor! áp dụng phép toán tử logic \textbf{nor}. cú pháp: \lstinline!{$nor: [ {<expression0>}, {<expression1>}, ... ,{<expressionN>} ] }! \\* ví dụ như \lstinline!db.NhanVien.find({$nor: [ {luong: 2000}, {mspb: "P01"} ] })! truy xuất các nhân viên thỏa:
\begin{itemize}
\item \textit{lương} khác 2000 và \textit{mspb} khác "P01"
\item \textit{lương} khác 2000 và không có trường \textit{mspb}
\item không có trường \textit{lương} và \textit{mspb} khác "P01"
\item không có cả trường \textit{lương} và trường \textit{mspb}
\end{itemize}
\end{itemize}
\section{Kiến trúc lưu trữ của MongoDB} \label{sec:MongoDB.4}
Cuối cùng, ở phần này ta sẽ đi chi tiết vào kiến trúc của MongoDB. Ta sẽ giới thiệu sơ về 2 định dạng dữ liệu JSON ở \ref{ssec:MongoDB.4.1} và BSON ở \ref{ssec:MongoDB.4.2}. Sau đó ta sẽ đi vào cốt lõi của việc lưu trữ dữ liệu của MongoDB trong phần \ref{ssec:MongoDB.4.3}.
\subsection{JSON} \label{ssec:MongoDB.4.1}
\textbf{JSON} (viết tắt cho \textit{JavaScript Object Notation}) là một định dạng lưu trữ, trao đổi dữ liệu nhẹ, con người có thể dễ dàng đọc và ghi cho cả con người và máy. JSON là định dạng được lưu dưới dạng text và không phụ thuộc vào ngôn ngữ lập trình sử dụng tuy cách kí hiệu gần gũi với các ngôn ngữ họ C như C, C++, C\#, Java, Javascript, Perl, Python,...

JSON được xây dựng dựa trên 2 cấu trúc dữ liệu nền tảng là:
\begin{itemize}
\item \textit{Tập hợp các cặp key-value (khóa-trị)} được gọi là \textit{object} (đối tượng).
\item \textit{Danh sách các giá trị} hay còn được gọi là \textit{array} (mảng).
\end{itemize}
Các loại dữ liệu (trị) mà JSON có thể nhận dạng là:
\begin{itemize}
\item string
\item number
\item object
\item array
\item true
\item false
\item null
\end{itemize}
\subsection{BSON} \label{ssec:MongoDB.4.2}
MongoDB lưu trữ dữ liệu dưới một phương thức biểu diễn nhị phân gọi là BSON. \textbf{BSON} (BinaryJSON) là phương thức mã hóa nhị phân các document với định dạng tương tự JSON. BSON còn mở rộng các kiểu dữ liệu, thêm vào một số kiểu dữ liệu mà JSON chưa có như Date, BinData.

Các thuộc tính chính của BSON:
\begin{itemize}
\item \textbf{Nhẹ}. Các overhead được tối giảm hết mức có thể.
\item \textbf{Khả duyệt tuần tự}. BSON được thiết kế có khả năng cho phép duyệt tuần tự dữ liệu.
\item \textbf{Hiệu quả}. Mã hóa và giải mã file BSON có thể được thực hiện nhanh chóng nhờ vào sử dụng các kiểu dữ liệu của C.
\end{itemize}
Ví dụ về mã hóa BSON:
\begin{lstlisting}

 {"hello": "world"}
->	

  \x16\x00\x00\x00                   // total document size
  \x02                               // 0x02 = type String
  hello\x00                          // field name
  \x06\x00\x00\x00world\x00          // field value
  \x00                               // 0x00 = type EOO ('end of object')

 {"BSON": ["awesome", 5.05, 1986]}
->	
  \x31\x00\x00\x00
  \x04BSON\x00
  \x26\x00\x00\x00
  \x02\x30\x00\x08\x00\x00\x00awesome\x00
  \x01\x31\x00\x33\x33\x33\x33\x33\x33\x14\x40
  \x10\x32\x00\xc2\x07\x00\x00
  \x00
  \x00
\end{lstlisting}
\subsection{Storage Engine} \label{ssec:MongoDB.4.3}
\textbf{Storage Engine} chính là bộ phận giữ vai trò quản lý lưu trữ dữ liệu trên bộ nhớ chính cũng như trên đĩa. MongoDB cho phép người dùng chọn các storage engine khác nhau trong nhiều trường hợp khác nhau. Việc chọn storage engine phù hợp với mục đích sử dụng sẽ giúp cải thiện hiệu năng của hệ thống sử dụng cơ sở dữ liệu.
\subsubsection{WiredTiger}
\textbf{WiredTiger} là storage engine mặc định kể từ MongoDB 3.2 trở đi. WiredTiger xuất hiện và thể hiện được sự mạnh mẽ của mình, qua đó trở thành lựa chọn thông dụng trong việc xây dựng CSDL.

WiredTiger kiểm soát song song hóa ở tầng document (\textbf{Document-level Concurrency Control}) cho các tác vụ ghi. Việc này có nghĩa là nhiều user có thể ghi đồng thời nhiều document khác nhau trong cùng một collection một cách song song. Phần lớn các tác vụ đọc, ghi được WiredTiger kiểm soát bằng Optimistic concurrency control. Khi phát hiện xung đột giữa 2 tác vụ, một trong 2 sẽ phát lỗi ghi dữ liệu khiến MongoDB sẽ thử thực hiện lại tác vụ đó sau.

Bên cạnh đó WiredTiger còn sử dụng \textbf{MultiVersion Concurrency Control} (MVCC). Khi bắt đầu tác vụ, WiredTiger sẽ tạo một \textbf{snapshot} - bản sao dữ liệu của cơ sở dữ liệu - thể hiện một phần nhỏ cơ sở dữ liệu vào trong bộ nhớ chính. Khi ghi xuống đĩa, WiredTiger ghi tất cả dữ liệu trong snapshot xuống đĩa. Dữ liệu lúc này đã trở nên bền vững và được xem là một checkpoint. \textbf{Checkpoint} có nhiệm vụ đảm bảo tính nhất quán của các file dữ liệu của cơ sở dữ liệu. Từ phiên bản \textit{3.6} thì WiredTiger tạo checkpoint mỗi 60 giây. Trong khi đang ghi checkpoint mới thì checkpoint cũ hợp lệ sẽ vẫn được giữ nên nếu có trường hợp xảy ra lỗi khi đang ghi dữ liệu xuống đĩa thì ta vẫn có thể khôi phục lại đến checkpoint cũ. Checkpoint mới chỉ được xem là bền vững khi bảng metadata của WiredTiger được cập nhật đồng nhất để tham chiếu đến checkpoint mới, khi đó checkpoint cũ mới được xóa.

Tuy với WiredTiger ta có thể khôi phục đến checkpoint cuối cùng nhưng để khôi phục các thay đổi sau checkpoint đó thì ta cần sử dụng thêm ghi log. WiredTiger sử dụng \textit{write-ahead transaction log} - tức là các thay đổi tạo ra do các transaction được log ghi nhận chỉ được phép ghi xuống đĩa nếu log đó đã được ghi xuống đĩa.

Với WiredTiger, MongoDB hỗ trợ nén dữ liệu cho tất cả collection và index. Nén giữ liệu sử dụng thêm năng suất từ CPU đổi lại giúp giảm dung lượng sử dụng của cơ sở dữ liệu. Mặc định WiredTiger dùng thư viện \textit{snappy} để nén các block dữ liệu và file log. Bên cạnh đó ta có thể chọn không nén dữ liệu hoặc nén bằng thuật toán khác như \textit{zlib}.
\subsubsection{MMAPv1}
\textbf{MMAPv1} là storage engine cơ bản của MongoDB dựa trên memory mapped file với các ưu điểm về hoạt động tốt với các tác vụ insert, reads số lượng lớn và in-place update.

Để đảm bảo tính bền vững của cơ sở dữ liệu, MongoDB mặc định ghi log tất cả các thay đổi vào file log (journal) trên đĩa. MongoDB ghi log thường xuyên hơn là ghi dữ liệu xuống đĩa. Mặc định ghi dữ liệu xuống đĩa mỗi 60 giấy còn ghi log mỗi 100 mili giây. Chính việc ghi log giúp MongoDB khôi phục dữ liệu khi xảy ra sự cố.

Các record sẽ được cấp phát bộ nhớ liên tục trên đĩa, dùng để lưu trữ các document. Nếu document trở nên lớn hơn kích thước record đã được cấp phát thì record mới sẽ được cấp phát và document sẽ được dời sang record mới đồng thời cập nhất các tham chiếu index tới document đó.
\subsubsection{So sánh WiredTiger và MMAPv1}
\begin{itemize}
\item \textbf{Song song}

MMAPv1 sử dụng Collection-level Concurrency Control. Nếu một người dùng thực hiện tác vụ thay đổi một document thì cả collection của document đó sẽ bị lock và các người dùng khác sẽ không thể truy cập collection đó. Ở các phiên bản trước thì MMAPv1 dùng Database-level Concurrency Control.

Còn WiredTiger sử dụng Document-level, Optimistic Concurrency Control.
\item \textbf{Logging (Journal)}

MMAPv1 dùng tính năng này để khôi phục.

WiredTiger sử dụng các checkpoint để khôi phục dữ liệu, có thể dùng thêm logging để khôi phục các thay đổi chưa được tạo checkpoint.
\item \textbf{Nén dữ liệu}

MMAPv1 không nén dữ liệu trong khi WiredTiger có thể nén dữ liệu theo giải thuật snappy hay zlib.
\end{itemize}
\subsubsection{In-memory Storage Engine}
Như tên gọi, \textbf{In-memory Storage Engine} lưu trữ toàn bộ dữ liệu, dữ kiện thiết lập, index,... trên bộ nhớ chính. Vì thế giảm thiểu lượng lớn thời gian hao tổn do các tác vụ I/O trên đĩa. In-memory Storage Engine chỉ dành cho phiên bản \textit{MongoDB Enterprise}.

In-memory Storage Engine dùng Document-level Concurrency Control.

Do toàn bộ dữ liệu chỉ được lưu trữ trên bộ nhớ chính nên đổi lại năng suất, tốc độ cao thì CSDL không có tính bền vững.